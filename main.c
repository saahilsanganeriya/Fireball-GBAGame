#include "main.h"

#include <stdio.h>
#include <stdlib.h>

#include "gba.h"
/* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
#include "images/start.c"
#include "images/fireball.c"
#include "images/gameover.c"
#include "images/sprite.c"
#include "images/won.c"

/* TODO: */
// Add any additional states you need for your app. You are not requried to use
// these specific provided states.
enum gba_state {
    START,
    GAMEPLAY,
    STARTBG,
    WON,
    GAMEOVER,
};


int main(void) {
    /* TODO: */
    // Manipulate REG_DISPCNT here to set Mode 3. //
    REG_DISPCNT = MODE3 | BG2_ENABLE;

    // Save current and previous state of button input.
    u32 previousButtons = BUTTONS;
    u32 currentButtons = BUTTONS;

    // Load initial application state
    enum gba_state state = START;

    Player p = {20, 80, 20, 20};
    Fireball fireballs[8];

    int numFireballs;
    int deltas[] = {1, 2, 3, 4};
    int ndeltas;
    u32 vblankthreshold;

    while (1) {
        currentButtons = BUTTONS; // Load the current state of the buttons

        /* TODO: */
        // Manipulate the state machine below as needed //
        // NOTE: Call waitForVBlank() before you draw

        switch (state) {
            case START:
                waitForVBlank();
                drawFullScreenImageDMA(start);
                if (KEY_DOWN(BUTTON_A, currentButtons)) {
                    //EASY
                    ndeltas = 1;
                    numFireballs = 2;
                    vblankthreshold = 600;
                    state = STARTBG;
                }
                if (KEY_DOWN(BUTTON_B, currentButtons)) {
                    //MEDIUM
                    ndeltas = 2;
                    numFireballs = 5;
                    vblankthreshold = 1500;
                    state = STARTBG;
                }
                if (KEY_DOWN(BUTTON_R, currentButtons)) {
                    //HARD
                    ndeltas = 4;
                    numFireballs = 8;
                    vblankthreshold = 2400;
                    state = STARTBG;
                }
                break;

            case STARTBG:
                waitForVBlank();
                p.x = 20;
                p.y = 80;
                p.h = 20;
                p.w = 20;

                for (int i = 0; i < numFireballs; i++) {
                    fireballs[i].state = 0;
                    fireballs[i].w = 10;
                    fireballs[i].h = 10;
                    fireballs[i].y = rand() % HEIGHT;
                    fireballs[i].x = rand() % WIDTH;
                    fireballs[i].yd = deltas[rand() % ndeltas];
                    fireballs[i].xd = deltas[rand() % ndeltas];
                }

                vBlankCounter = 0;
                state = GAMEPLAY;
                break;

            case GAMEPLAY:
                waitForVBlank();
                fillScreenDMA(BLACK);

                for (int i = 0; i < numFireballs; i++) {
                    if (fireballs[i].state == 1) {
                        drawImageDMA(fireballs[i].y, fireballs[i].x, fireballs[i].w, fireballs[i].h, fireball);
                    }

                    if ((fireballs[i].y + fireballs[i].yd < 150) && (fireballs[i].y + fireballs[i].yd > 0)) {
                        fireballs[i].y += fireballs[i].yd;
                    } else {
                        fireballs[i].yd= -fireballs[i].yd;
                        fireballs[i].y += fireballs[i].yd;
                    }

                    if ((fireballs[i].x + fireballs[i].xd < 230) && (fireballs[i].x + fireballs[i].xd > 0)) {
                        fireballs[i].x += fireballs[i].xd;
                    } else {
                        fireballs[i].xd = -fireballs[i].xd;
                        fireballs[i].x += fireballs[i].xd;
                    }

                    if ((fireballs[i].state == 1) &&((p.x < fireballs[i].x + fireballs[i].w) && (p.x + p.w > fireballs[i].x) && (p.y < fireballs[i].y + fireballs[i].h) && (p.h + p.y > fireballs[i].y))) {
                        state = GAMEOVER;
                    }
                }

                drawImageDMA(p.y, p.x, p.w, p.h, sprite);
                char limit[50];
                char time[50];
                sprintf(time, "%lu", ((unsigned long)(vBlankCounter / 60)));
                drawString(150, 2, time, WHITE);
                drawString(150, 15, "/", WHITE);
                sprintf(limit, "%lu", ((unsigned long)(vblankthreshold / 60)));
                drawString(150, 25, limit, WHITE);
                if (vBlankCounter >= vblankthreshold) {
                    state = WON;
                }
                fireballs[vBlankCounter / 360].state = 1;

                if (KEY_DOWN(BUTTON_DOWN, BUTTONS)) {
                    if (p.y < 140) {
                        p.y++;
                    }
                }
                if (KEY_DOWN(BUTTON_UP, BUTTONS)) {
                    if (p.y > 0) {
                        p.y--;
                    }
                }
                if (KEY_DOWN(BUTTON_LEFT, BUTTONS)) {
                    if (p.x > 0) {
                        p.x--;
                    }
                }
                if (KEY_DOWN(BUTTON_RIGHT, BUTTONS)) {
                    if (p.x < 220) {
                        p.x++;
                    }
                }

                if (KEY_DOWN(BUTTON_SELECT, BUTTONS)) {
                    state = START;
                }

                break;
            case WON:
                waitForVBlank();
                drawFullScreenImageDMA(won);
                if (KEY_DOWN(BUTTON_SELECT, BUTTONS)) {
                    state = START;
                }
                break;
            case GAMEOVER:
                waitForVBlank();
                drawFullScreenImageDMA(gameover);
                if (KEY_DOWN(BUTTON_SELECT, BUTTONS)) {
                    state = START;
                }
                break;
        }

        previousButtons = currentButtons; // Store the current state of the buttons
    }

    UNUSED(previousButtons); // You can remove this once previousButtons is used

    return 0;
}
